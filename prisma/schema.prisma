generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Owner {
  id         String  @id @default(cuid())
  firebaseId String  @unique
  name       String?
  email      String?
  photoURL   String?
  teamSize   String? // Team size for owner context (e.g., "just-me", "2-10", "11-50", "51-200", "200+")

  // Microsoft OAuth integration (bolted directly onto Owner)
  microsoftAccessToken  String? // Microsoft Graph access token
  microsoftRefreshToken String? // Refresh token for getting new access tokens
  microsoftExpiresAt    DateTime? // Token expiration timestamp
  microsoftEmail        String? // Microsoft account email (for display)
  microsoftDisplayName  String? // Microsoft account display name (for display)
  microsoftTenantId     String? // Tenant ID extracted from ID token (for tenant-specific token refresh)

  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  managedCompanies CompanyHQ[]     @relation("ManagerOf")
  ownedCompanies   CompanyHQ[]     @relation("OwnerOf")
  emailActivities  EmailActivity[] // Outreach email tracking
  assessments      Assessment[]    // Growth assessments

  @@map("owners")
}

model EmailActivity {
  id        String   @id @default(cuid())
  ownerId   String   @map("owner_id")
  contactId String?  @map("contact_id")
  tenantId  String?  @map("tenant_id")
  email     String
  subject   String
  body      String
  event     String? // last known state: delivered, opened, clicked, bounced, etc.
  messageId String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner Owner @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([ownerId])
  @@index([messageId])
  @@index([contactId])
  @@map("email_activities")
}

model CompanyHQ {
  id               String        @id @default(cuid())
  companyName      String
  companyStreet    String? // Street address
  companyCity      String? // City
  companyState     String? // State
  companyWebsite   String? // Website URL (for LinkedIn extraction, etc.)
  whatYouDo        String? // What the company does (description)
  companyIndustry  String?
  companyAnnualRev Float?
  yearsInBusiness  Int?
  teamSize         String? // Team size for company (e.g., "just-me", "2-10", "11-50", "51-200", "200+")
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  ownerId          String? // Owner.id (for legacy Owner model) - optional for Contact-owned HQs
  contactOwnerId   String? // Contact.id (for Contact-owned HQs) - when Contact becomes owner
  managerId        String?
  companies        Company[]
  manager          Owner?        @relation("ManagerOf", fields: [managerId], references: [id])
  owner            Owner?       @relation("OwnerOf", fields: [ownerId], references: [id]) // Made optional
  contactOwner     Contact?      @relation("ContactOwnedHQs", fields: [contactOwnerId], references: [id]) // Contact who owns this HQ
  contactLists     ContactList[]
  contacts         Contact[]
  proposals        Proposal[]
  products         Product[]
  personas         Persona[]
  assessments      Assessment[]
  memberships      CompanyMembership[] // Junction table for multi-HQ access

  @@map("company_hqs")
}

model Company {
  id              String     @id @default(cuid())
  companyHQId     String
  companyName     String
  address         String?
  industry        String?
  website         String? // Website URL (inferred from email domain or manually entered)
  revenue         Float?
  yearsInBusiness Int?
  proposalId      String?
  contractId      String?
  invoiceId       String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  companyHQ       CompanyHQ  @relation(fields: [companyHQId], references: [id], onDelete: Cascade)
  contacts        Contact[]
  proposals       Proposal[] // Reverse relation - proposals linked to this company

  @@map("companies")
}

model ContactList {
  id          String    @id @default(cuid())
  companyId   String
  name        String
  description String?
  type        String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  companyHQ   CompanyHQ @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contacts    Contact[]

  @@map("contact_lists")
}

model Contact {
  id                  String       @id @default(cuid())
  crmId               String // CompanyHQId (tenant identifier) - renamed from companyId for clarity
  firstName           String?
  lastName            String?
  goesBy              String?
  email               String?  @unique
  phone               String?
  title               String?
  contactCompanyId    String? // Company they work for (prospect/client company)
  buyerDecision       String?
  howMet              String?
  notes               String? // Notes/context about the contact
  contactListId       String?
  domain              String? // Domain from enrichment
  companyName         String? // Company name from enrichment
  enrichmentSource    String? // Source of enrichment (e.g., "Lusha")
  enrichmentFetchedAt DateTime? // When enrichment was fetched
  enrichmentPayload   Json? // Full enrichment payload
  createdById         String? // User who created this contact
  
  // Client Portal Activation
  firebaseUid         String?  @unique // Firebase Auth UID
  clientPortalUrl    String?  @default("https://clientportal.ignitegrowth.biz") // Portal URL for this contact
  isActivated        Boolean  @default(false) // Has completed activation flow
  activatedAt        DateTime? // When activation was completed
  
  // Elevation to Owner
  ownerId             String? // Contact.id (self-reference when they become owner of their own HQ)
  role                String   @default("contact") // "contact" | "owner"
  
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  companyHQ           CompanyHQ    @relation(fields: [crmId], references: [id])
  contactCompany      Company?     @relation(fields: [contactCompanyId], references: [id])
  contactList         ContactList? @relation(fields: [contactListId], references: [id])
  pipeline            Pipeline?
  deliverables        ConsultantDeliverable[]
  invites             InviteToken[] // Invite tokens for activation
  ownedHQs            CompanyHQ[]  @relation("ContactOwnedHQs") // HQs owned by this Contact
  // Note: memberships are queried via firebaseUid, not direct relation (due to nullable firebaseUid)

  @@index([email])
  @@index([firebaseUid])
  @@index([ownerId])
  @@index([role])
  @@map("contacts")
}

model Product {
  id                    String    @id @default(cuid())
  companyHQId           String
  name                  String
  description           String?
  valueProp             String?
  price                 Float? // Price in base currency
  priceCurrency         String?   @default("USD") // Currency code (USD, EUR, etc.)
  pricingModel          String? // one-time, recurring, usage-based, freemium, custom
  category              String? // Category or type of product/service
  deliveryTimeline      String? // How long it takes to deliver
  targetMarketSize      String? // enterprise, mid-market, small-business, startup, individual
  salesCycleLength      String? // immediate, short, medium, long, very-long
  features              String? // Key features (free text)
  competitiveAdvantages String? // Competitive advantages (free text)
  targetedTo            String? // Persona ID that this product is targeted to
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  companyHQ             CompanyHQ @relation(fields: [companyHQId], references: [id], onDelete: Cascade)
  personas              Persona[]

  @@map("products")
}

model Pipeline {
  id        String   @id @default(cuid())
  contactId String   @unique
  pipeline  String
  stage     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  contact   Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@map("pipelines")
}

model Proposal {
  id          String    @id @default(cuid())
  companyHQId String // Multi-tenancy - scoped to CompanyHQ
  companyHQ   CompanyHQ @relation(fields: [companyHQId], references: [id], onDelete: Cascade)

  // Client information
  clientName    String
  clientCompany String // Company name (can link to Company model later via companyId)
  companyId     String? // Optional: Link to Company model (prospect/client company)
  company       Company? @relation(fields: [companyId], references: [id], onDelete: SetNull)

  // Proposal details
  purpose    String? // Purpose/description of the proposal
  status     String  @default("draft") // "draft" | "active" | "approved" | "rejected"
  totalPrice Float? // Total price of all services

  // Proposal structure (stored as JSON for flexibility)
  serviceInstances Json? // Array of ProposalServiceInstance (from ProposalBuilder)
  phases           Json? // Array of Phase objects (with deliverables, activities, kpis)
  milestones       Json? // Array of Milestone objects (week, label, completed)
  compensation     Json? // Compensation object (total, currency, breakdown, paymentSchedule)

  // Metadata
  dateIssued DateTime? // Date proposal was issued
  preparedBy String? // Who prepared the proposal

  createdAt    DateTime                @default(now())
  updatedAt    DateTime                @updatedAt
  deliverables ConsultantDeliverable[]

  @@map("proposals")
}

model Persona {
  id                 String    @id @default(cuid())
  companyHQId        String
  name               String
  role               String?
  title              String?
  industry           String?
  goals              String?
  painPoints         String?
  desiredOutcome     String?
  valuePropToPersona String?
  alignmentScore     Int?
  productId          String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  companyHQ          CompanyHQ @relation(fields: [companyHQId], references: [id], onDelete: Cascade)
  product            Product?  @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@map("personas")
}

model ConsultantDeliverable {
  id          String   @id @default(cuid())
  contactId   String   // Link to Contact (the client)
  contact    Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  
  // What we're delivering
  title       String
  description String?
  category    String? // "foundation", "integration", "enrichment", etc.
  
  // Status tracking
  status      String   @default("pending") // "pending" | "in-progress" | "completed" | "blocked"
  
  // Link to proposal/milestone
  proposalId  String?
  proposal    Proposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  milestoneId String? // Reference to milestone in Proposal.milestones JSON (e.g., "milestone-1", "week-4")
  
  // Delivery tracking
  dueDate     DateTime?
  completedAt DateTime?
  notes       String?
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([contactId])
  @@index([proposalId])
  @@map("consultant_deliverables")
}

model ProspectCandidate {
  id          String   @id @default(cuid())
  userId      String
  firstName   String?
  lastName    String?
  companyName String?
  domain      String?
  status      String   @default("pending")
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([status])
  @@map("prospect_candidates")
}

model Assessment {
  id                   String   @id @default(cuid())
  ownerId              String
  owner                Owner    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  companyHQId          String?  // Optional: Link to CompanyHQ
  companyHQ            CompanyHQ? @relation(fields: [companyHQId], references: [id], onDelete: SetNull)
  
  // Assessment responses
  name                 String
  company              String
  industry             String?
  workTooMuch          String?  // "always" | "often" | "sometimes" | "rarely"
  assignTasks          String?  // "never" | "rarely" | "sometimes" | "always"
  wantMoreClients      String?  // "yes" | "maybe" | "no"
  revenueGrowthPercent Float?   // Percentage (e.g., 25 for 25%)
  totalVolume          Float?   // Total revenue/volume
  bdSpend              Float?   // Business development spend
  
  // Calculated results
  score                Int?     // 0-100 score
  scoreInterpretation  String?  // "High Growth Potential" | "Medium Growth Potential" | etc.
  relateWithUser       String?  // First paragraph of insights
  growthNeeds          String?  // Second paragraph of insights
  rawGptResponse       String?  // Full GPT response
  
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  
  @@index([ownerId])
  @@index([companyHQId])
  @@map("assessments")
}

model ClientUpload {
  id           String   @id @default(cuid())
  ownerId      String
  fileUrl      String
  originalName String
  fileType     String?
  size         Int?
  status       String   @default("stored")
  createdAt    DateTime @default(now())

  @@index([ownerId])
  @@map("client_uploads")
}

model InviteToken {
  id          String   @id @default(cuid())
  contactId   String
  email       String
  token       String   @unique
  expiresAt   DateTime
  used        Boolean  @default(false)
  createdAt   DateTime @default(now())

  contact     Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([contactId])
  @@index([email])
  @@map("invite_tokens")
}

model CompanyMembership {
  id           String   @id @default(cuid())
  userId       String   // Contact.firebaseUid (maps to Firebase Auth UID) - stored as string
  companyHqId  String
  role         String   // "client" | "owner" | "admin"
  isPrimary    Boolean  @default(false) // Primary HQ for this user
  createdAt    DateTime @default(now())

  // Note: userId stores firebaseUid as string - query Contact manually via firebaseUid
  // Prisma doesn't support relations on nullable unique fields easily
  companyHQ    CompanyHQ @relation(fields: [companyHqId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([companyHqId])
  @@index([userId, companyHqId])
  @@unique([userId, companyHqId]) // Prevent duplicate memberships
  @@map("company_memberships")
}
